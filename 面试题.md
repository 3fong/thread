## 面试题

- 实现一个容器,提供两个方法:add,size
写两个线程,线程1添加10个元素到容器中,线程2实现监控元素的个数,当个数到5时,线程2给出提示并结束;

分析:
```
1 全局变量不需要volatile再来修饰,因为它本身就是线程共享的;由于是引用数据类型 volatile 的添加其实并没有作用;它本身就是全局变量,不同线程具备可见性    

```


a 通过wait,notify实现:

1 问题 计时可能不准确,
2 共享数据可见性的问题;引用数据类型修改实际值,但是它的引用方应该是无感知的
3 计数递增判断条件不可靠 
if(c.size==5){} 这个数据可能被跳过
4 容器选择也要安全 Collections.synchronizedList();

b CountDownLatch实现
多步骤执行要注意原子性操作;

c locksupport park unpark 


- 写一个固定容量同步容器,拥有put和get方法,以及getCount(),能支持2个
生产者线程和10个消费者线程的阻塞调用

sync
lock while if的使用

threadpool(2)

volatile count;
thread {
    put()
}
threadpool(10)
thread {
    getCount()>0
    get()
}


- 两个线程依次打印A1B2..Z26




















