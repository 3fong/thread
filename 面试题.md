## 面试题

- 实现一个容器,提供两个方法:add,size
写两个线程,线程1添加10个元素到容器中,线程2实现监控元素的个数,当个数到5时,线程2给出提示并结束;

分析:
```
1 全局变量不需要volatile再来修饰,因为它本身就是线程共享的;由于是引用数据类型 volatile 的添加其实并没有作用;它本身就是全局变量,不同线程具备可见性;同时因为全局变量的可见性问题,要注意多线程全局变量,尤其是引用类型对于结果的干扰    
2 控制线程间执行顺序可以通过锁的wait,notify方法来控制;为了准确控制线程计数,要有两个wait,notify方法,才能避免计数时的锁竞争问题    
3 CountDownLatch实现    
4 locksupport park unpark    
```



a 通过wait,notify实现:

[wait,notify实现](multithreaddemo/src/main/java/com/ll/interview/Monitor3.java)

1 问题 计时可能不准确,
2 共享数据可见性的问题;引用数据类型修改实际值,但是它的引用方应该是无感知的
3 计数递增判断条件不可靠 
if(c.size==5){} 这个数据可能被跳过
4 容器选择也要安全 Collections.synchronizedList();

b CountDownLatch实现

一次只能有一个线程可以获取执行令牌,从而控制读取和添加操作;    
多步骤执行要注意原子性操作;

[wait,notify实现](multithreaddemo/src/main/java/com/ll/interview/MonitorLatch.java)

c locksupport park unpark 


- 写一个固定容量同步容器,拥有put和get方法,以及getCount(),能支持2个
生产者线程和10个消费者线程的阻塞调用

1 sync: synchornized wait notifyAll;    
2 lock: lock,unlock,condition.await,condition.signalAll;



- 两个线程依次打印A1B2..Z26




















