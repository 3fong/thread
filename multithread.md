## 多线程

![multithread概览](snapshot/multithread概览.png)
![multithread概览](snapshot/java多线程结构图.jpg)

### base concept
进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。    
线程:操作系统能操作进行运算调度的最小单位.它被包含子进程中,是进程中的实际运作单位.    
一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

- 分类

用户级线程: 管理过程全部由用户程序完成，操作系统内核心只对进程进行管理。    
系统级线程（核心级线程）: 由操作系统内核进行管理。操作系统内核给应用程序提供相应的系统调用和应用程序接口API，以使用户程序可以创建、执行、撤消线程。    
在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。    

- 进程与线程的关系:

同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。    
但同一进程中的多个线程有各自的调用栈（call stack）,寄存器环境（register context）,本地存储（thread-local storage）。
通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。

具体区别:    
```
1）地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
2）通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
3）调度和切换：线程上下文切换比进程上下文切换要快得多。
4）在多线程OS中，进程不是一个可执行的实体。
```

- 使用场景

1 服务器中的文件管理或通信控制
2 前后台处理
3 异步处理

- 特点:

轻型实体.基本不拥有系统资源,只需要一些必需的独立运行资源.包括程序,数据,TCB线程控制块TCB（Thread Control Block）    
独立调度和分派的基本单位    
可并发执行.    
共享进程资源.所有线程都具有相同的地址空间（进程的地址空间）;可以访问进程所拥有的已打开文件、定时器、信号量机构等;    



- 启动线程的三种方式    

Thread,Runnable, ExcutorThreadPool线程池

- 常用方法:

yield,join,sleep


不建议用 stop

interrupt用于程序底层退出,同时通知其他线程终止运行,业务实现中一般用不到.


### 同步

线程由于共享进程的数据段,这样对于竞争资源,就存在数据一致性问题.    
线程在程序中是独立的、并发的执行路径，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。    
进程可以支持多个线程，它们看似同时执行，但互相之间并不同步。一个进程中的多个线程共享相同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。尽管这让线程之间共享信息变得更容易，但您必须小心，确保它们不会妨碍同一进程里的其它线程。

线程属性:线程的外在特征:线程体(run()),线程状态(生命周期阶段)

![线程状态](snapshot/thread-status.png)    
![线程状态](https://bkimg.cdn.bcebos.com/pic/a5c27d1ed21b0ef4a9c88f08ddc451da81cb3e47?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto)

由于多线程存在共享变量竞争导致数据一致性问题,它可以通过同步来解决.

Java Object Model:    
![Java Object Model](https://bkimg.cdn.bcebos.com/pic/6f061d950a7b020884d329b762d9f2d3572cc84a?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto)

数据一致性问题:

	原子性
	可见性
	执行顺序

共享资源数据一致性问题:
	
synchronized既可以保证可见性也能保证原子性,但是无法解决指令重排序的问题;
volatile:可见性和禁止指令重排序;但是无法保证原子性

- synchronized(Object)

```
锁的是对象不是代码    
this T.class(static)    
锁定方法和非锁定方法可同时执行    
锁升级(偏向锁,自旋锁,重量级锁)    
```

锁是任意object对象    
锁不建议使用基础数据类型和String.因为基础数据类型和string都会创建缓存池,容易造成潜在的锁共用,引起死锁问题.

synchronized method = synchronized(this)
synchronized static method = synchronized(T.class)

静态方法是单例吗?一般是,但是不同的**类加载器**可以生成不同的静态方法,静态类.



类加载顺序

同步方法调用时是否允许调用非同步方法?
脏读的典型场景,写加锁,读不加锁,这时就可能读取到中间状态,这个并不一定是问题,需要看自己的业务场景是否允许.

可重入:

	同一把锁是否允许当前线程访问拥有同一把锁的其他方法,如果运行则是可重入,不允许则不可重入.
	可重入对于Java很重要,比较典型的场景是子类访问父类方法,如果不可重入,则会出现同一把锁无法调用父类方法的问题.
	
	


### 锁升级:	

偏向锁    
自旋锁 线程数少    
重量级锁 线程数多,线程操作时间长    

自旋锁:

CAS自旋锁
![CAS自旋锁](snapshot/cas.png)

- 指令重排序((读写屏障))

指令重排序:是指编译器或CPU为了优化程序的执行性能而对指令进行重新排序的一种手段，重排序会带来可见性问题，所以在多线程开发中必须要关注并规避重排序。

从源代码到最终运行的指令，会经过如下两个阶段的重排序。

第一阶段，编译器重排序，就是在编译过程中，编译器根据上下文分析对指令进行重排序，目的是减少CPU和内存的交互，重排序之后尽可能保证CPU从寄存器或缓存行中读取数据。避免了处理器每次都去内存中加载stop，减少了处理器和内存的交互开销.    
第二阶段，处理器重排序，处理器重排序分为两个部分

	并行指令集重排序，这是处理器优化的一种，处理器可以改变指令的执行顺序。    
	内存系统重排序，这是处理器引入Store Buffer缓冲区延时写入产生的指令执行顺序不一致的问题，在后续内容中会详细说明。


- 并行指令集

在处理器内核中一般会有多个执行单元，比如算术逻辑单元、位移单元等。在引入并行指令集之前，CPU在每个时钟周期内只能执行单条指令，也就是说只有一个执行单元在工作，其他执行单元处于空闲状态；在引入并行指令集之后，CPU在一个时钟周期内可以同时分配多条指令在不同的执行单元中执行。

![并行指令集的重排序](https://ask.qcloudimg.com/http-save/yehe-5119234/ce05dbaf01e7ca575b731eb10668dc36.png?imageView2/2/w/1620)

对于一条从内存中读取数据的指令，CPU的某个执行单元在执行这条指令并等到返回结果之前，按照CPU的执行速度来说它足够处理几百条其他指令，而CPU为了提高执行效率，会根据单元电路的空闲状态和指令能否提前执行的情况进行分析，把那些指令地址顺序靠后的指令提前到读取内存指令之前完成。

实际上，这种优化的本质是通过提前执行其他可执行指令来填补CPU的时间空隙，然后在结束时重新排序运算结果，从而实现指令顺序执行的运行结果。

- as-if-serial语义

as-if-serial表示所有的程序指令都可以因为优化而被重排序，但是在优化的过程中必须要保证是在单线程环境下，重排序之后的运行结果和程序代码本身预期的执行结果一致，Java编译器、CPU指令重排序都需要保证在单线程环境下的as-if-serial语义是正确的。在多线程中，重排序会带来可见性问题。

另外，为了保证as-if-serial语义是正确的，编译器和处理器不会对存在依赖关系的操作进行指令重排序，因为这样会影响程序的执行结果。我们来看下面这段代码。

```
public void execute(){
    int x=10;  //1
    int y=5;   //2
    int c=x+y; //3
}
```

上述代码按照正常的执行顺序应该是1、2、3，在多线程环境下，可能会出现2、1、3这样的执行顺序，但是一定不会出现3、2、1这样的顺序，因为3与1和2存在数据依赖关系，一旦重排序，就无法保证as-if-serial语义是正确的。但是在CPU层面还存在内存系统重排序问题，内存系统重排序也会导致可见性问题。

- volatile

![volatile](snapshot/volatile.png)
可以解决可见性和指令重排序(顺序性)

volatile无法替代synchronized,因为它无法解决原子性问题.如: count++;

volatile无法保证原子性     
![volatile无法保证原子性](snapshot/volatile无法保证原子性.png)


单例与volatile

单例懒汉式:双重检查


new对象过程(内存分配流程):
	1 分配内存
	2 初始化(设置默认值)
	3 复制

但是指令重排序可能发生在new的流程中,造成线程不安全

ASM进行编译二进制可执行文件

### 锁优化:

锁细化 只加载需要进行一致性处理的业务逻辑上    
锁粗化 同一个方法中有多个锁处理,可以通过锁合并来优化


- CAS

ABA问题:AtomicStampedReference
基础数据类型没有问题;引用类型,可能存在间接引用对象的修改问题.

obj -> A -> ref C
	-> B -> ref D
	-> A -> ref D

	这时比较线程再获取obj的引用对象还是A,但是实际的间接引用已经被修改了

- Atomic*的实现  

保证数据操作的原子性实现.它实际是基于Unsafe类进行实现,JDK11中使用单例获取Unsafe类对象

AtomicInteger
![AtomicInteger](snapshot/AtomicInteger.png)

Unsafe    

![Unsafe](snapshot/unsafe.png)















静态与线程安全的关系.静态是否可以使线程安全??




















